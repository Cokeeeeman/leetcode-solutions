# 924. Minimize Malware Spread

## Question

> In a network of nodes, each node `i` is directly connected to another node `j` if and only if `graph[i][j] = 1`.
>
> Some nodes `initial` are initially infected by malware.  Whenever two nodes are directly connected and at least one of those two nodes is infected by malware, both nodes will be infected by malware.  This spread of malware will continue until no more nodes can be infected in this manner.
>
> Suppose `M(initial)` is the final number of nodes infected with malware in the entire network, after the spread of malware stops.
>
> We will remove one node from the initial list.  Return the node that if removed, would minimize `M(initial)`.  If multiple nodes could be removed to minimize `M(initial)`, return such a node with the smallest index.
>
> Note that if a node was removed from the `initial` list of infected nodes, it may still be infected later as a result of the malware spread.
>
> 1. 
> **Example 1:**
>
> ```text
> Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
> Output: 0
> ```
>
> **Example 2:**
>
> ```text
> Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
> Output: 0
> ```
>
> **Example 3:**
>
> ```text
> Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
> Output: 1
> ```
>
> **Note:**
>
> 1. `1 < graph.length = graph[0].length <= 300`
> 2. `0 <= graph[i][j] == graph[j][i] <= 1`
> 3. `graph[i][i] = 1`
> 4. `1 <= initial.length < graph.length`
> 5. `0 <= initial[i] < graph.length`

## Analysis

One property to note: if in the `initial` set, there's 2 nodes connected, then removing either of those two won't change the final number of nodes get infected.

So we want to find the node in `initial` that's not connected to any other nodes in the same set.

What if there's more than 1 node in `initial` that doesn't connect to other nodes? Then we see which one connects to more nodes in the entire graph.

So we need to:

1. Color/group the graph nodes by their connection by assigning color to each node.
2. Check the colors in the set `initial` and check which nodes have the only color in the set.
   1. If more than 1 node in `initial` has unique color, we compare which one connects more nodes in entire graph, by checking the nodes in same color.
      * If they connect to same amount of nodes, we pick the one with smaller index;
   2. If we don't find any nodes in `initial` that has unique color, that means for each of them, they connect to at least one other node in the same set. So removing them wouldn't matter. We'll just pick the one with smallest index.

#### Solution \#1: DFS

Time complexity would be `O(n^2)`, since the graph is represented in adjacency matrix.

#### Solution \#2: Union-find

Time complexity would be`O(n^2)`. Space `O(n)`.

## Code

#### Solution \#1: DFS

```text
/**
 * @param {number[][]} graph
 * @param {number[]} initial
 * @return {number}
 */
var minMalwareSpread = function(graph, initial) {
  const n = graph.length;
  
  // colorByNode[i] is the color of node i
  const colorByNode = Array(n).fill(-1);
  
  let color = 0;
  for (let i = 0; i < n; i++) {
    if (colorByNode[i] === -1) {
      dfs(graph, colorByNode, i, color++);
    }
  }
  
  // count # of nodes for each color in the graph
  const countByColor = Array(color).fill(0);
  for (let color of colorByNode) {
    countByColor[color] += 1;
  }
  
  // count # of nodes for each color in initial set
  const countByColorInitial = Array(color).fill(0);
  for (let node of initial) {
    countByColorInitial[colorByNode[node]] += 1;
  }
  
  let res = null;
  for (let node of initial) {
    const color = colorByNode[node];
    const count = countByColorInitial[color];
    if (count !== 1) continue;

    if (
      res === null ||
      countByColor[color] > countByColor[colorByNode[res]] ||
      (countByColor[color] === countByColor[colorByNode[res]] && node < res)
    ) {
      res = node;
    }
  }
  
  if (res === null) {
    res = Math.min(...initial);
  }
  
  return res;
};

const dfs = (graph, colorByNode, node, color) => {
  colorByNode[node] = color;
  
  for (let neighbor = 0; neighbor < graph.length; neighbor++) {
    if (graph[node][neighbor] === 1 && colorByNode[neighbor] === -1) {
      dfs(graph, colorByNode, neighbor, color);
    }
  }
};
```

#### Solution \#2: Union-find

```text
var minMalwareSpread = function(graph, initial) {
  const n = graph.length;
  const ds = new DS(n);
  
  for (let i = 0; i < n; i++) {
    for (let j = i + 1; j < n; j++) {
      if (graph[i][j] === 1) {
        ds.union(i, j);
      }
    }
  }
  
  const numOfSets = ds.numOfSets;
  const countBySetInitial = new Map();
  for (let node of initial) {
    const set = ds.find(node);
    if (!countBySetInitial.has(set)) {
      countBySetInitial.set(set, 0);
    }
    countBySetInitial.set(set, countBySetInitial.get(set) + 1);
  }

  let res = null;
  for (let node of initial) {
    const set = ds.find(node);
    console.log(`Set=${set}, node=${node}`);
    if (countBySetInitial.get(set) === 1) {
      if (
        res === null ||
        ds.getSetSizeByNode(node) > ds.getSetSizeByNode(res) ||
        (ds.getSetSizeByNode(node) === ds.getSetSizeByNode(res) && node < res)
      ) {
        res = node;
      }
    }
  }
  
  
  if (res === null) {
    res = Math.min(...initial);
  }
  return res;
};

// Disjoint Set
class DS {
  constructor(size) {
    this.numOfSets = size;
    this.parent = [];
    for (let i = 0; i < size; i++) {
      this.parent[i] = i;
    }
    // initially every node is a set and has size 1
    this.sizeBySet = Array(size).fill(1);
  }
  
  find(x) {
    if (this.parent[x] === x) {
      return x;
    }
    const px = this.parent[x];
    return this.find(px);
  }
  
  union(x, y) {
    const setX = this.find(x);
    const setY = this.find(y);
    
    if (setX !== setY) {
      this.parent[setX] = setY;
      this.sizeBySet[setY] += this.sizeBySet[setX];
      this.numOfSets -= 1;
    }
  }
  
  getSetSizeByNode(x) {
    return this.sizeBySet[this.find(x)];
  }
  
  
}
```

